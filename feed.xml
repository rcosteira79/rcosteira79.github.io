<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-06-23T13:10:24+01:00</updated><id>/feed.xml</id><title type="html">Ricardo Costeira</title><subtitle>A mobile software engineer with a passion for Android and clean, maintainable code. I build apps from the ground up and maintain existing ones. Currently out of my area of expertise in order to diversify my skills on software design and architecture.</subtitle><entry><title type="html">How not to use sealed classes and LiveData for state management</title><link href="/how-not-to-use-sealed-classes-and-livedata-for-state-management" rel="alternate" type="text/html" title="How not to use sealed classes and LiveData for state management" /><published>2019-05-28T11:00:00+01:00</published><updated>2019-05-28T11:00:00+01:00</updated><id>/how-not-to-use-sealed-classes-and-livedata-for-state-management</id><content type="html" xml:base="/how-not-to-use-sealed-classes-and-livedata-for-state-management">&lt;p&gt;A few months ago, I was washing my dishes while listening to &lt;a href=&quot;https://fragmentedpodcast.com/episodes/148/&quot;&gt;episode 148 of the Fragmented podcast&lt;/a&gt;. In this episode, Donn Felker and Kaushik Gopal talk about architecture. To be specific, about an MVI-like architecture that Kaushik has been using.&lt;/p&gt;

&lt;p&gt;This architecture specifies that each screen has one and only one ViewModel, that exposes a single observable to the Activity or Fragment. This observable emits the screen’s state: when an update is required, the observable emits a new state object, which the view uses to update its state. To emit a state update, the ViewModel has to receive an event. Different events trigger different updates. Events then generate results, which generate the state updates. Each event class has a corresponding result class.&lt;/p&gt;

&lt;p&gt;There are many other nuances around the architecture, but these are the ones that matter for this article.&lt;/p&gt;

&lt;h3 id=&quot;the-epiphany&quot;&gt;The Epiphany&lt;/h3&gt;

&lt;p&gt;In the &lt;a href=&quot;https://github.com/kaushikgopal/movies-usf&quot;&gt;sample repo&lt;/a&gt; that Kaushik provides, you can see this example of a view state class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;data class MSMovieViewState(
    val searchBoxText: String? = null,
    val searchedMovieTitle: String = &quot;&quot;,
    val searchedMovieRating: String = &quot;&quot;,
    val searchedMoviePoster: String = &quot;&quot;,
    val searchedMovieReference: MSMovie? = null,
    val adapterList: List&amp;lt;MSMovie&amp;gt; = emptyList()
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is quite similar to a &lt;a href=&quot;https://martinfowler.com/eaaDev/PresentationModel.html&quot;&gt;presentation model&lt;/a&gt;, but without the behavior definition. Also, as you can see, the class is immutable. This means that whenever there’s a new state update, the old values get copied into a new object. This new object also has the updated value for each specific state change. For example, given the events class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;sealed class MSMovieEvent {
    object ScreenLoadEvent : MSMovieEvent()
    data class SearchMovieEvent(val searchedMovieTitle: String = &quot;&quot;) : MSMovieEvent()
    data class AddToHistoryEvent(val searchedMovie: MSMovie) : MSMovieEvent()
    data class RestoreFromHistoryEvent(val movieFromHistory: MSMovie) : MSMovieEvent()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for a “add to history event”, you would have something like (this is an oversimplified version of the repo’s code):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;val movie: MSMovie = result.packet.movie

val newState = oldState.copy(
  searchedMovieTitle = movie.title,
  searchedMovieRating = movie.ratingSummary,
  searchedMoviePoster = movie.posterUrl,
  searchedMovieReference = movie)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I saw this, my train of thought was more or less like “OK, this looks nice. Every state detail becomes enclosed in the same object. But this also means I have to redraw the whole UI on each update, even if I just change a simple text label. This seems rather heavy…”.&lt;/p&gt;

&lt;p&gt;I was really hyped about the architecture, but this bummed me out a little. There must be another way…&lt;/p&gt;

&lt;p&gt;And then it dawned on me: “What if I tried to use sealed classes for this?”&lt;/p&gt;

&lt;h3 id=&quot;keep-it-simple-also-keep-it-working-correctly&quot;&gt;Keep it simple. Also, keep it working correctly&lt;/h3&gt;

&lt;p&gt;Kaushik makes heavy usage of RxJava in this architecture. I love RxJava and think it’s amazing. Yet, like many, I also think that in most cases it’s an overkill. Especially when the framework already provides similar tools for the most common cases. Instead of using RxJava, I’ll be using LiveData for observability. For async work, I’ll use Coroutines. I also won’t be using events or results. Results seem rather redundant when you have observability. As for the events, they also seem to be superfluous: I have methods causing state changes. As such, observability should take care of everything for me, right? Eh, not quite, but we’ll get to that later.&lt;/p&gt;

&lt;p&gt;Before I start explaining what I’m about to do, I want to make something clear: I’m not recommending an architecture of any kind. I’m just testing a different approach to an already well defined architecture, and writing about the results. Nothing more. That being said, let’s get started.&lt;/p&gt;

&lt;p&gt;I’ll be implementing a Fragment that displays a RecyclerView with a list of user names. Each row has a checkbox that gets checked/unchecked either when you click on it or on the row itself. A button at the bottom of the view will update its label according to the number of selected users. I could’ve picked an even simpler example, but I really wanted to test the limits of this approach.&lt;/p&gt;

&lt;p&gt;So, I have two pieces of state here: the contents of the RecyclerView and the button label. I also have the actual user list internal state, i.e., if rows are checked or not. However, since we can consider this as the RecyclerView’s internal state, I’ll let it slide (otherwise, this approach is already failing…).&lt;/p&gt;

&lt;p&gt;I came up with the following sealed class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;sealed class RecyclerViewExampleViewState {
  data class UsersListState(val users: List&amp;lt;DisplayedUser&amp;gt;) : RecyclerViewExampleViewState()
  data class ButtonLabelState(val numberOfUsers: String) : RecyclerViewExampleViewState()
  data class PossibleFailureState(val failure: Failure) : RecyclerViewExampleViewState()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The ViewModel that does all the heavy lifting:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;class RecyclerViewExampleViewModel @Inject constructor(
  private val getUsers: GetUsers,
  private val displayedUserMapper: DisplayedUserMapper
) : BaseViewModel() {

  val viewState: LiveData&amp;lt;RecyclerViewExampleViewState&amp;gt;
    get() = _viewState

  private val _viewState: MutableLiveData&amp;lt;RecyclerViewExampleViewState&amp;gt; =
    MutableLiveData()

  init {
    getUsers()
    updateButtonLabel(0)
  }

  fun updateButtonLabel(checkedNumber: Int) {
    val label = if (checkedNumber &amp;gt; 0) &quot; ($checkedNumber)&quot; else &quot;&quot;
    _viewState.value = ButtonLabelState(label)
  }

  private fun getUsers() = getUsers(uiScope, UseCase.None()) {
    it.either(
      ::handleFailure,
      ::handleUserList
    )
  }

  private fun handleFailure(failure: Failure) {
    _viewState.value = PossibleFailureState(failure)
  }

  private fun handleUserList(users: List&amp;lt;User&amp;gt;) {
    val usersToDisplay = users.map { displayedUserMapper.mapToUI(it) }
    _viewState.value = UsersListState(usersToDisplay)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the Fragment that updates its view on each state update:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;class RecyclerViewExampleFragment
: BaseFragment(), RecyclerViewRowClickListener&amp;lt;DisplayedUser&amp;gt; {

  @Inject
  lateinit var viewModel: RecyclerViewExampleViewModel

  lateinit var adapter: UsersAdapter

  override fun onCreateView(
    inflater: LayoutInflater, container: ViewGroup?,
    savedInstanceState: Bundle?
  ): View? {

    return inflater.inflate(R.layout.fragment_recycler_view_example, container, false)
  }

  override fun onActivityCreated(savedInstanceState: Bundle?) {
    super.onActivityCreated(savedInstanceState)

    progressBarLoading.show()
    setRecyclerView()

    viewModel = createViewModel(this) {
      observe(viewLifecycleOwner, viewState, ::renderViewState)
    }
  }

  private fun setRecyclerView() {
    prepareAdapter()
    recyclerViewUsers.layoutManager = LinearLayoutManager(this.context)
    recyclerViewUsers.adapter = adapter
    recyclerViewUsers.setHasFixedSize(true)
  }

  private fun prepareAdapter() {
    adapter = UsersAdapter(this)
  }

  private fun renderViewState(state: RecyclerViewExampleViewState) {

    when (state) {
      is UsersListState -&amp;gt; renderUserList(state.users)
      is ButtonLabelState -&amp;gt; renderButton(state.numberOfUsers)
      is PossibleFailureState -&amp;gt; renderPossibleFailure(state.failure)
    }
  }

  private fun renderUserList(users: List&amp;lt;DisplayedUser&amp;gt;) {
    progressBarLoading.hide()
    adapter.submitList(users)
  }

  private fun renderButton(selectedUsers: String) {
    buttonDoStuff.text =
      getString(R.string.button_label_do_stuff_with_users, selectedUsers)
    buttonDoStuff.isEnabled = !selectedUsers.isBlank()
  }

  private fun renderPossibleFailure(failure: Failure) {
    // TODO computer says no
  }

  override fun onRowClicked(item: DisplayedUser, position: Int) {
    val checkedNumber = adapter.currentList.filter { it.isChecked }.count()
    viewModel.updateButtonLabel(checkedNumber)
  }

  override fun onDestroyView() {
    super.onDestroyView()
    recyclerViewUsers.adapter = null
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let me walk you through the code. When the ViewModel inits, it immediately tells the repository to fetch the users (GitHub API). It then updates the button label. The Fragment uses the renderViewState method to observe the LiveData. For each different state update, renderViewState will trigger a different method. The Fragment also implements the RecyclerViewRowClickListener interface. This interface allows us to react to clicks on RecyclerView items. The Fragment does this in the onRowClicked method.&lt;/p&gt;

&lt;p&gt;This is the result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/how-not-to-use-sealed-classes-and-livedata-for-state-management-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Everything seemingly works as I expected, except for one small (but important) detail. As you may have noticed, the onRowClicked method filters the user list. The filter counts the number of checked rows. Why? Because I can’t use this approach to update state based on a previous state. In other words, because each sealed class is independent. To me, this is the worst disadvantage of using a single LiveData to handle all these state classes: when I create a state update with a certain value, I lose access to it as soon as I set it as the LiveData’s value. Of course, I could always verify the LiveData value on the next state iteration. Unfortunately, I cannot guarantee that the previous update was the one I need. Suddenly, a simple class with the whole state just like Kaushik has seems worth it. Either that or I would need a different LiveData for this specific piece of state. This would also solve the internal RecyclerView state problem I talked about earlier.&lt;/p&gt;

&lt;p&gt;Anyway, since the use of another LiveData would solve this, I decided to press on. I wasn’t ready to give up on this sealed classes idea. This time, I rotated the screen. And then this happened:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/how-not-to-use-sealed-classes-and-livedata-for-state-management-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Dammit. Why?&lt;/p&gt;

&lt;p&gt;Well, I forgot a very important aspect of LiveData. Each new observer that subscribes to a LiveData receives its &lt;strong&gt;latest&lt;/strong&gt; value. Here, the Fragment gets destroyed on rotation, and a new Fragment starts observing the LiveData. The last value emitted by the LiveData was the button label update. That’s why the label is correct, but the list is empty. If I rotate the phone before clicking on any rows, the list will appear since the getUsers API request is async and finishes after the updateButtonLabel call. On the other hand, the button label will show the placeholder text instead of the correct value.&lt;/p&gt;

&lt;p&gt;So, ways to solve this. One possibility is, again, different LiveData variables for each sealed class. This is not the most desirable solution though. If we keep adding new LiveData variables, both code maintenance and testing complexity might increase. This was one of the motives between Kaushik’s architecture, if I recall correctly. Another, more sane possibility is to trigger view state updates in the Fragment’s onResume method or similar. Suddenly, events make sense. The third option I can think of breaks my heart: use a class for the whole state, instead of sealed classes (Sorry Kaushik, I will never doubt your work again).&lt;/p&gt;

&lt;h3 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h3&gt;

&lt;p&gt;I ended up using a single class to the whole state . With the LiveData and sealed classes setup, I got to a point where I had a different LiveData for each sealed class, which defeats the purpose of the whole thing. I even had to stop ignoring the RecyclerView’s internal state, since it gets reset on configuration changes.&lt;/p&gt;

&lt;p&gt;I’m also using events, although there was no functional need for them in this case: since LiveData will always emit the latest global state for the view, I don’t need to cause an explicit state update on configuration change. Regardless, they do make the code look more structured to me. I like having all state changing events going through the same method. It feels like this should help in keeping things more or less simple on a more complex UI. In the end, the architecture became a simplified version of the one presented in the Fragmented podcast.&lt;/p&gt;

&lt;p&gt;Although redrawing the whole UI seems exaggerated, the process is actually very smooth. While this might not hold for a more complex UI, it should be able to handle most cases.&lt;/p&gt;

&lt;p&gt;You can find all the code (in its final state) in my &lt;a href=&quot;https://github.com/rcosteira79/AndroidMultiModuleCleanArchTemplate&quot;&gt;multi module clean architecture template&lt;/a&gt;, in the &lt;code&gt;RecyclerViewExample&lt;/code&gt; module.&lt;/p&gt;

&lt;p&gt;As I said before, this is not an architecture recommendation. While this might work for some cases, other alternatives such as databinding or multiple LiveData variables managed by a MediatorLiveData (as suggested by Gabor Varadi in the comments) might even be a better fit. I’m a fan of this approach, but it’s up to you to figure out what’s best for your specific case.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Thank you very much for reading the article. I really hope it was worth it! Do you have any ideas? Would you do something differently? If so, please leave a comment or reach out on Twitter. See you next time!&lt;/p&gt;</content><author><name>Ricardo Costeira</name></author><category term="Android" /><summary type="html">A few months ago, I was washing my dishes while listening to episode 148 of the Fragmented podcast. In this episode, Donn Felker and Kaushik Gopal talk about architecture. To be specific, about an MVI-like architecture that Kaushik has been using.</summary></entry><entry><title type="html">Encapsulate and abstract for future proof software</title><link href="/encapsulate-and-abstract-for-future-proof-software" rel="alternate" type="text/html" title="Encapsulate and abstract for future proof software" /><published>2019-04-22T11:00:00+01:00</published><updated>2019-04-22T11:00:00+01:00</updated><id>/encapsulate-and-abstract-for-future-proof-software</id><content type="html" xml:base="/encapsulate-and-abstract-for-future-proof-software">&lt;p&gt;Change will always affect your software. No matter the domain, the uses cases, the developers, or even the users. Change is the one constant in software development.&lt;/p&gt;

&lt;p&gt;This is one of the first topics addressed by the authors of the renowned &lt;a href=&quot;http://shop.oreilly.com/product/9780596007126.do&quot;&gt;Head First Design Patterns&lt;/a&gt;. They approach it as one reason for the importance of design patterns. As they say in the book:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“No matter how well you design an application, over time an application must grow and change or it will &lt;em&gt;die&lt;/em&gt;.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Along with design patterns, the authors also introduce a bundle of design principles. While the patterns are outside the scope of this article, I want to focus on the first two principles:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Encapsulate what varies.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Program to interfaces, not implementations.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first principle is the basis for all design patterns, and most of them also make use of the second one. The first one dictates that if you have code that keeps changing, pull it out and isolate it. The second principle complements this through the use of interfaces.&lt;/p&gt;

&lt;p&gt;Now, a word of caution. As &lt;a href=&quot;https://medium.com/@techyourchance&quot;&gt;Vasiliy Zukanov&lt;/a&gt; explained in &lt;a href=&quot;https://medium.com/@techyourchance/i-havent-read-head-first-design-patterns-yet-but-i-heard-that-it-s-a-worthy-book-b53f72e9b495&quot;&gt;this comment&lt;/a&gt;, this “interface” does not refer to the interface construct seen in some OOP languages. Well, it can refer to it, but it has a broader meaning. Here, “interface” refers to a component’s external point of interaction. It is what other components can use to interact with the specific component. So, this “interface” can be an interface, an abstract class, a normal class or even a function. It can be anything as long as it serves as a communication point with the component. With it, we need not know the inner details of the component. It lets us &lt;strong&gt;abstract&lt;/strong&gt; from the component’s implementation. So, whenever there’s a change, you only need to refactor the corresponding code. The outside code will never even notice it. The purpose of the principle is indeed to focus on &lt;strong&gt;what&lt;/strong&gt; the code does, and not &lt;strong&gt;how&lt;/strong&gt; it does it.&lt;/p&gt;

&lt;h3 id=&quot;a-ticking-time-bomb-android-libraries&quot;&gt;A ticking time bomb: Android Libraries&lt;/h3&gt;

&lt;p&gt;The Android open source community is awesome. No matter the complexity of what you need, a library implementing it is likely to exist already. This not only makes our jobs easier but also lets us focus on the true business logic problems.&lt;/p&gt;

&lt;p&gt;Yet, things change (I know). Libraries become obsolete. Sometimes, new versions introduce breaking changes. Requirements change, and we no longer need a library. External changes force us to change our code. We’re left with a huge codebase full of deprecated dependencies or code built around them. This is where the design principles mentioned above come in handy.&lt;/p&gt;

&lt;p&gt;Suppose that you need to store/retrieve a Configuration object on/from disk in JSON format. You have experience with Gson from previous projects, so you use it. You defined Configuration as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;data class Configuration(
  val aNumber: Int,
  val somethingWithCharacters: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You first start by creating an abstraction for Gson. Here, a simple class will do (unless you’re using &lt;a href=&quot;http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&quot;&gt;Clean Architecture&lt;/a&gt;: in that case, you would probably have this class implement an interface):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;/** Imports */

class ConfigurationStorageHandler {

  private val gson: Gson

  // ...

  fun read(): Configuration {
    val jsonConfiguration = /** Get json string from disk */
    return gson.fromJson(jsonConfiguration, Configuration::class.java)
  }

  fun write(configuration: Configuration) {
    val jsonString = gson.toJson(configuration)
    /** Store jsonString on disk */
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, you use it along with the rest of your product:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;class MagicBusiness constructor(
  private val configurationStorageHandler: ConfigurationStorageHandler
) {
  // ...

  fun doMagicAccordingToConfig() {
    val config = configurationStorageHandler.read()
    /** use config for magic */
  }

  fun saveConfigForLateNightMagic(configuration: Configuration) {
    /** 10x programmer magic */

    configurationStorageHandler.write(configuration)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;class MagicActivity : AppCompatActivity() {

  // ...

  override fun onCreate(savedInstanceState: Bundle?) {
    // ...
    val storageHandler = ConfigurationStorageHandler()
    val magicBusiness = MagicBusiness(
      configurationStorageHandler = storageHandler
    )
    // ...
  }

  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time goes by, and your abstraction gets sprinkled throughout your code. One day, you come across this hip library called Moshi, that also deals with json parsing. Moshi seems to be faster, more flexible, and works like a charm when used together with Retrofit. You got to use it.&lt;/p&gt;

&lt;p&gt;Luckily, you saw this coming. You use Gson everywhere in your code. But since you have it encapsulated, you can swap it with Moshi almost for free!&lt;/p&gt;

&lt;p&gt;Simply replace Gson with Moshi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;/** Imports */

class ConfigurationStorageHandler {

  private val moshi: Moshi

  // ...

  fun read(): Configuration {
    val jsonConfiguration = /** Get json string from disk */
    val adapter = moshi.adapter(Configuration::class.java)

    return adapter.fromJson(jsonConfiguration)
  }

  fun write(configuration: Configuration) {
    val adapter = moshi.adapter(Configuration::class.java)
    val jsonString = adapter.toJson(configuration)
    /** Store jsonString on disk */
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And you’re done — all the code that used Gson now uses Moshi. Just by changing this class.&lt;/p&gt;

&lt;p&gt;You can later change libraries again. You can even ditch json and use something else. As long as you create the proper abstraction (which is actually the hard part), you’re good to go. Your code is now robust and flexible, and your future self will be proud.&lt;/p&gt;

&lt;p&gt;Note that the codebase is further improved by injecting the dependencies. Even if you don’t use Dagger or any other framework — the dependency injection itself is what matters. This way, you keep your classes decoupled and set yourself up for easy testing. Here, if you inject a mock or fake storage handler, you can test &lt;code&gt;MagicBusiness&lt;/code&gt; in isolation.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Abstractions Live Longer than Details“ — The Pragmatic Programmer, chapter 7, page 209&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I showed you an example of how you can create boundaries around your code. These boundaries protect your code from external dependencies. Still, it goes much deeper than this. Recipes like design patterns or architectural patterns such as Clean Architecture are great. They’re battle tested, and their usefulness is more than proven. Using these design principles is one reason for their greatness. You can (and should!) apply these design principles even if you don’t use external code. Use them with caution, though. We know that design principle abuse increases code complexity. It’s a commitment you must consider, and balance with care.&lt;/p&gt;</content><author><name>Ricardo Costeira</name></author><category term="Android" /><summary type="html">Change will always affect your software. No matter the domain, the uses cases, the developers, or even the users. Change is the one constant in software development.</summary></entry></feed>